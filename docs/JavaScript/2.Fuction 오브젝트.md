---
id: JS2
title: 2.Function 오브젝트
---
_[자바스크립트 중고급: 근본 핵심 이해](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A4%91%EA%B3%A0%EA%B8%89#)을 보고 학습한 내용을 정리한 것입니다._

## Function 오브젝트 형태, 생성
- function 형태
    - 빌트인 Function 오브젝트
        - Function.prototype.call() (메소드명) 의 형태로 되어 있다.
    - function 오브젝트
        - function book() {...}
        - var book = function(){...}
        - 이것도 인스턴스이지만, new 연산자로 생성한 인스턴스와 구분하기 위해 function 오브젝트로 표기한다.
    - function 인스턴스
        - new Book() 처럼 new 연산자를 사용하여 Book.prototype에 연결된 메소드로 생성한다.
    
- function 오브젝트 생성
    - var book = function() {...};
    - 엔진이 function 키워드를 만나면 빌트인 Function 오브젝트의 prototype에 연결된 메소드로 function 오브젝트를 생성한다.
    - 생성한 오브젝트를 book 변수에 할당한다.
    - function 오브젝트이므로 book() 형태로 호출할 수 있다.

- 오브젝트 저장
    - 함수를 호출하려면 생성한 function 오브젝트를 저장해야 한다.
    - function 오브젝트의 저장 형태는 **key/value 형태**
        - {name : value} 형태로 저장한다.
        - ex) {book: 생성한 function 오브젝트}
    - 함수를 호출하면 
        - 1. 저장된 오브젝트에서 **함수 이름(book)**으로 검색한다.
        - 2. value 값을 구하고 value가 function 오브젝트이면 호출한다.

- 생각의 전환
    - 함수가 호출되면 엔진은 함수의 변수와 함수를 **{name:value} 프로퍼티 형태**로 실행 환경을 설정하고 함수 코드를 실행한다.
    - {name:value} 프로퍼티 형태로 생각을 전환하자. 
    - function (){} 코드를 보면 함수의 변수와 함수가 {name:value} 형태로 연상되어야 한다.
        - 엔진 관점에서 보기
    

## function 오브젝트 생성 과정
- 상황 : function sports() {...} 형태에서 function 키워드를 만나면 ?
    - 오브젝트 생성하고 저장 -> {sports: {...}}
        - sports는 function 오브젝트 이름
        - 오브젝트 {...}에 프로퍼티가 없는 상태
        - 이제부터 빈 오브젝트를 채운다.

- sports 오브젝트 형태
1. 
```js
sports = {
    prototype: {
        constructor: sports
        __proto__: {}
    }
}
```
- sports 오브젝트에 prototype 오브젝트 첨부
- prototype에 constructor 프로퍼티 첨부
    - prototype.constructor가 sports 오브젝트 첨부
- prototype에 \__proto__ 오브젝트 첨부
    - \__proto__ 는 ES6 스펙에 기술되어 있다.

2. 
```js
sports = {
    arguments: {},
    caller: {},
    length: 0,
    name: "sports",
    prototype: {
        constructor: sports,
        __proto__: Object.prototype
    },
    __proto__: Function.prototype
}
```
- 빌트인 Object.prototype의 메소드로 Object 인스턴스를 생성한다.
    - prototype.\__proto__ 오브젝트에 첨부한다.
- sports 오브젝트에 \__proto__ 오브젝트 첨부
    - sports.\__proto__ 구조가 된다.
- 빌트인 Functio.prototype의 메소드로 function 인스턴스를 생성한다.
    - sports.\__proto__ 에 첨부한다.
- sports 이 Function 오브젝트이므로 
    - 첫 번째 depth의 \__proto__ 
        - `call()`: 함수 호출
        - `apply()`: 함수 호출 → 배열을 파라미터로 사용
        - `toString()`: 함수를 문자열로 반환
        - `bind()`: 새로운 오브젝트를 생성하고 함수 실행
    - 두 번째 depth의 \__proto__ 에 Object.prototype 의 메소드가 설정됨.
        - `valueOf()`: Primitive 값 반환
        - `hasOwnProperty()`: 프로퍼티 소유 여부 반환
        - `propertyIsEnumerable()`: 프로퍼티 열거 여부 반환
        - `isPrototype()`: prototype의 존재 여부 반환
        - `toString()`: 문자열로 변환
        - `toLocaleString()`: 지역화 문자열로 변환
- sports 오브젝트 프로퍼티에 초기값 설정
    - arguments, caller, length, name 프로퍼티


### function 오브젝트 구조 정리 
- function 오브젝트에 prototype이 있으며
    - constructor 가 연결된다.
    - \__proto__ 가 연결되어 있다. (위의 6개의 메소드)
    - Object 인스턴스가 연결된다.
- function 오브젝트에 \__proto__ 가 있으며
    - Function 인스턴스가 연결된다.
    - Array 이면 Array 인스턴스가 연결되고
    - String 이면 String 인스턴스가 연결된다.
- 엔진 관점에서 sports는 Object
    - 그 안에는 property로 구성되어 있다. -> key/value

## function 실행 환경 저장
- 함수 실행 환경 인식
    - 함수 실행 환경 인식이 필요한 이유?
        - 함수가 호출되었을 때 실행될 환경을 알아야 실행 환경에 맞추어 실행할 수 있기 때문이다.
    - 실행 환경 설정 시점
        - function 키워드를 만나 function 오브젝트를 생성할 때 이다.
    - 설정하는 것
        - 실행 영역(함수가 속한 스코프 -> 정적 스코프)
        - 파라미터, 함수 코드 등
- 함수 실행 환경 저장
    - function 오브젝트를 생성하고 바로 실행하지 않으므로 함수가 호출되었을 때 사용할 수 있도록 환경을 저장해야 한다.
    - 어디에 저장?
        - **생성한 function 오브젝트에 저장한다.**
    - 생성한 function 오브젝트의 내부 프로퍼티로 인식한 환경을 {name:value}로 설정 한다.
- 내부 프로퍼티 ?
    - 내부 프로퍼티란 엔진이 내부 처리에 사용하는 프로퍼티로 스펙 표기로 외부에서 사용 불가하다.
        - 스펙 표기 : [[ ]] 형태 
        - ex) [[ '프로퍼티 이름' ]]
