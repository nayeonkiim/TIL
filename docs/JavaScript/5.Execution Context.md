---
id: JS5
title: 5.Execution Context
---
_[자바스크립트 중고급: 근본 핵심 이해](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A4%91%EA%B3%A0%EA%B8%89#)을 보고 학습한 내용을 정리한 것입니다._

## 실행 콘텍스트
- Execution context
    - 함수가 실행되는 영역, 묶음이다.
    - 함수 코드를 실행하고 실행 결과를 저장한다.
        - 변수에 값 할당하거나 다른 함수 호출해서 리턴값 저장 등
    - **함수를 호출할 때마다 함수 컨텍스트가 하나씩 생긴다.**
    - 엔진의 처리, 스펙상의 사양 -> 3개의 component가 존재한다.
        - Lexical Environment
        - Variable Environment
        - ThisBinding<br/><br/>

    - 
    ```js
    function music(title) {
        var musicTitle = title;
    };
    music("음악");
    ```
    - music("음악") 으로 함수를 호출하면 엔진은 **실행 콘텍스트**를 생성하고 실행 콘텍스트 안으로 이동한다.
    - 실행 콘텍스트 실행 단계
        - 준비 단계, 초기화 단계, 코드 실행단계

- Execution Context 생성 단계
    - 실행 가능한 코드를 만났을 때 생성한다.
    - 실행 가능한 코드에는 함수코드, 글로벌 코드, eval 코드 가 있다.
    - 코드 유형을 분리한 이유는 실행 콘텍스트에서 **처리 방법과 실행 환경**이 다르기 때문이다.
        - 함수 코드 : 렉시컬 환경
        - 글로벌 코드 : 글로벌 환경
        - eval 코드 : 동적 환경

- 실행 콘텍스트 상태 컴포넌트
    - 실행 콘텍스트 상태를 위한 오브젝트로 실행 콘텍스트 안에 생성한다.
    ```js
    실행 콘텍스트(EC): {
        렉시컬 환경 컴포넌트(LEC): { },

        변수 환경 컴포넌트(VEC): { },

        this 바인딩 컴포넌트(TBC): { }
    }
    ```
    - 상태 컴포넌트 유형
        - 렉시컬 환경 컴포넌트(LEC)
            - Lexical Environment Component
            - 정적 환경이지만 글로벌과 동적 환경도 같이 사용할 수 있다.
        - 변수 환경 컴포넌트(VEC)
            - Variable Environment Component
        - this 바인딩 컴포넌트(TBC)
            - This Binding Component
            - 함수 안에서 this로 참조하는 오브젝트
            - obj.abc 를 했을 때, obj를 abc 함수 안에서 this로 참조할 수 있다.

## 렉시컬 환경 컴포넌트
- 함수와 변수의 **식별자 해결**을 위한 환경 설정이다.
- 함수 초기화 단계에서 해석한 함수와 변수를 {name:value} 형태로 저장한다.
    - 변수 : {변수이름 : undefind}
    - 함수 : {함수이름 : function object}
    - 이름으로 함수와 변수를 검색할 수 있게 된다.
- 함수 밖의 함수와 변수 참조 환경 설정한다.
    - **함수 밖의 함수와 변수를 사용**할 수 있게된다.

### 렉시컬 환경 컴포넌트 구성
- 렉시컬 환경 컴포넌트는 funciton, with문, try-catch 에서 생성된다.
- 컴포넌트 구성
    - **환경 레코드**(Environment Record)
        - 함수 안의 함수와 변수를 기록한다.
    - **외부 렉시컬 환경 참조**(Outer Lexical Environment Reference)
        - function 오브젝트의 내부 프로퍼티인 [[Scope]]를 설정한다.
            - function 키워드를 만나 function 오브젝트를 만들 때 설정했다.
            - 위 설정한 것을 **함수가 호출되면 외부 렉시컬 환경 참조에 설정**한다.
    - 따라서 함수 안과 밖의 함수와 변수를 **하나의 묶음, 하나의 context** 에서 사용할 수 있게 된다.
- 실행 콘텍스트가 메모리에 올라가있는 상태이다. 횐경 레코드와 외부 렉시컬 환경 참조에 의해 메모리 안에서 한번에 처리가 가능하다. -> **Context의 렉시컬 개념**

## 변수 환경 컴포넌트
- 실행 콘텍스트 초기화 단계에서 렉시컬 환경 컴포넌트에 설정된 것과 동일하게 설정한다.
- 동일하게 설정하는 이유?
    - 초깃값을 복원할 때 사용하기 위한 것이다.
- 함수 코드가 실행되면 실행 결과를 렉시컬 환경 컴포넌트에 설정한다. 실행 결과에 의해 값이 변경되면 렉시컬 환경 컴포넌트의 값이 변한다. 즉 초깃값이 변하게 되는데 이를 유지하기 위한 것이다.
- with 문에서 사용한다.

## 실행 콘텍스트 실행 과정
```js
var base = 200;
function getPoint(bonus) {
    var point = 100;
    return point + base + bonus;
};
console.log(getPoint(70));
```
1. getPoint 오브젝트의 [[Scope]]에 글로벌 오브젝트를 설정한다.
2. var base의 초기화와 값 할당을 한다.
3. 마지막 줄에서 getPoint() 를 호출하면 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동한다.

- 준비 단계 - 실행 콘텍스트에서 실행할 수 있는 환경을 만든다.
4. 컴포넌트를 생성하여 실행 콘텍스트에 첨부한다.
    - 렉시컬 환경 컴포넌트, 변수 환경 컴포넌트, this 바인딩 컴포넌트
5. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부한다.
    - 함수 안에 함수, 변수를 바인딩 한다. 현재는 준비 과정이므로 빈 오브젝트 이다.
    - 여기까지의 모습
    ```js
    실행 콘텍스트(EC): {
        렉시컬 환경 컴포넌트(LEC) = {
            환경 레코드(ER): {}
        },
        변수 환경 컴포넌트(VEC): {},
        this 바이딘 컴포넌트(TBC): {}
    }
    ```
6. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부하고
    function 오브젝트의 [[Scope]] 를 설정한다.
    - getPoint 의 [[Scope]] 에 설정된 Scope를 외부 렉시컬 환경 참조에 설정한다. 값이 변할 수 있으므로 참조이다.
    - 여기까지의 모습
    ```js
    실행 콘텍스트(EC): {
        렉시컬 환경 컴포넌트(LEC) = {
            환경 레코드(ER): {},
            외부 렉시컬 환경 참조(OLER):{
                base: 200
            }
        },
        변수 환경 컴포넌트(VEC): {},
        this 바이딘 컴포넌트(TBC): {}
    }
    ```

- 초기화 단계 
7. 호출한 함수의 파라미터 값을 호출된 함수의 파라미터 이름에 매핑한다. 환경 레코드에 작성한다.
    - `bonus : 70`
8. 함수 선언문을 function 오브젝트로 생성한다.
9. 함수 표현식과 변수에 초기값 설정한다.
    - `point: undefined`
10. 여기까지는 외부에 실행 상태를 제공하지 않는다.
    - 설정된 렉시컬 환경 컴포넌트 안의 값을 설정하거나 처리하지 못한다. -> 엔진의 내부처리 이다.
    - 여기까지의 모습
    ```js
    실행 콘텍스트(EC): {
        렉시컬 환경 컴포넌트(LEC) = {
            환경 레코드(ER): {
                bonus: 70,
                point: undefined
            },
            외부 렉시컬 환경 참조(OLER):{
                base: 200
            }
        },
        변수 환경 컴포넌트(VEC): {},
        this 바이딘 컴포넌트(TBC): {}
    }
    ```
    
- 실행 단계
11. 함수 표현식과 변수에 값을 할당한다.
     - `point: 100`
12. 실행 컨텍스트 안에서 관련된 함수와 변수를 사용할 수 있다.
    - point + base + bonus 실행이 가능하다.
    - point는 환경 레코드에 100으로 존재하고 base는 외부 렉시컬 환경 참조에 200 으로 존재. bonus는 환경 레코드에 70으로 존재 -> 100+200+70 인 370을 리턴한다.
- 렉시컬 환경 안에서 모든 것이 실행 가능하다.

### 정리하기
```js
function book(){
    function get() {
        return point;
    };
    var point = 123;
    return get();
};
console.log(book());
```
1. function 키워드를 만나 function 오브젝트를 생성하고 [[Scope]] 에 글로벌 스코프로 설정한다.
2. book 함수가 호출되어 실행 컨텍스트를 생성한다.
    - 위에서 글로벌 스코프를 설정 해둔 [[Scope]]에 외부 렉시컬 환경 참조에 설정한다.
    - 환경 레코드에 `{get : function 오브젝트}`, `{point:undefined}` 로 설정한다.
3. book() 함수 안으로 들어간다.
4. function 키워드에 의해 get function 오브젝트가 생성되고 get function [[Scope]]에 book function의 [[Scope]]를 설정한다.
5. point 변수에 123 값이 할당 된다.
6. get() 함수가 호출되어 get()으로 들어간다.
    - 새로운 실행 컨텍스트가 생성된다.
    - 새로운 실행 컨텍스트의 환경 레코드에서 먼저 찾고 없으면 외부 렉시컬 환경 참조에서 point를 찾는다.
    - 외부 렉시컬 환경 참조에서 point로 값을 찾고 이것을 리턴한다.




## 환경 레코드
```js
실행 콘텍스트(EC): {
    렉시컬 환경 컴포넌트(LEC): {
        환경 레코드(ER): {
            선언적 환경 레코드(DER): {
                point: 123
            },
            오브젝트 환경 레코드(OER): {}
        },
        외부 렉시컬 환경 참조(OLER): {}
    },
    변수 환경 컴포넌트(VEC): {},
    this 바인딩 컴포넌트(TBC): {}
}
```
- 환경 레코드 구성
    - 환경 레코드 구분하는 이유는 기록 대상에 따라 다르기 때문이다.
    - 선언적 환경 레코드
        - fuction, 변수, catch 문에서 사용한다.
        - 정적이다.
    - 오브젝트 환경 레코드
        - 글로벌 함수와 변수, with문에서 사용한다.
        - 정적이 아니라 동적이다. 
            - ex) with문을 한번 돌 때마다 동적으로 만들어진다.

## 글로벌 환경
```js
실행 콘텍스트(EC): {
    글로벌 환경(GE): {
        환경 레코드(ER): {
            오브젝트 환경 레코드: 글로벌 오브젝트
        },
        외부 렉시컬 환경 참조(OLER): null
    }
}
```
- 글로벌 오브젝트에서 사용한다.
- 렉시컬 환경 컴포넌트와 형태가 같다.
- 다만 차이는 글로벌 오브젝트는 동적으로 함수와 변수를 바인딩 한다.
    - 함수에서 var 키워드를 사용하지 않고 변수를 선언하면 글로벌 변수가 되고 글로벌 오브젝트에 설정되기 때문이다.
    - 정적은 한번 설정 시 변하지 않는다. var 키워드는 변경이 가능하다. -> 동적
    - 글로벌 오브젝트는 소스 전체를 통해서 하나만 존재한다.
        - 글로벌 환경을 하나만 만들어 놓으면 어느 코드에서든지 동적으로 저장을 할 수 있다. 
    - 어디에 속하지 않으므로 외부 렉시컬 환경 참조는 null 이다.

## this 바인딩 컴포넌트
- 목적
    - this로, 함수를 호출한 **오브젝트의 프로퍼티**에 액세스한다.
    - ex) this.propertyName
- 액세스 매커니즘
    - obj.book() 형태에서 this로 obj를 참조할 수 있도록 **this 바인딩 컴포넌트에 obj 참조**를 설정한다.
- obj의 프로퍼티가 변경되면 동적으로 참조한다. 설정이 아닌 참조이기 때문에 가능하다.

- this 바인딩 과정
```js
var obj = {point:100};
obj.getPoint = function(){
    return this.point;
};
obj.getPoint();
```
1. 마지막 줄에서 obj.getPoint() 함수 호출
2. 실행 콘텍스트 생성한다.
3. 3개의 컴포넌트 생성한다.
    - 렉시컬/변수 환경 컴포넌트, this 바인딩 컴포넌트
4. this 바인딩 컴포넌트에 getPoint()에서 this로 obj의 프로퍼티를 사용할 수 있도록 바인딩한다.
```js
...
실행 콘텍스트: {
    렉시컬 환경 컴포넌트:{
        환경 레코드(ER): {
            선언적 환경 레코드: {},
            오브젝트 환경 레코드: {}
        },
        외부 렉시컬 환경 참조: {}
    },
    변수 환경 컴포넌트: {},
    this 바인딩 컴포넌트(TBC): {
        point: 100,
        getPoint: function(){}
    }
}
```
5. 초기화를 위해 getPoint 함수 안으로 들어간다.
    - 파라미터, 함수 선언문, 변수 선언이 없다.
6. return this.point; 실행
7. this 바인딩 컴포넌트에서 point 검색
    - getPoint() 함수를 호출한 오브젝트(obj)가 this 바인딩 컴포넌트에 참조된 상태
8. this 바인딩 컴포넌트에 point 프로퍼티가 있으므로 100을 반환한다.
9. obj.getPoint() 에서 obj의 프로퍼티가 this 바인딩 컴포넌트에 바인딩되도록 의도적으로 설계해야 한다.


## 호출 스택(call stack)
- 실행 콘텍스트의 논리적 구조이다.
- **FILO 순서**
    ```js
    function one(){
        two();
        console.log(1);
    };
    function two(){
        three();
        console.log(2);
    };
    function three(){
        console.log(3);
    };
    one();
    ```
    - 함수가 호출되면 스택의 가장 위에 실행 콘텍스트가 위치하게 된다.
    - 다시 함수 안에서 함수를 호출하면 호출된 함수의 실행 콘텍스트가 스택의 가장 위에 놓이기 된다.
    - 함수가 종료되면 스택에서 빠져나옴(FILO 순서로)
    - 제일 위 -> 아래
        - three() - two() - one()
        - 실행 결과가 `3 2 1` 이 출력 된다.
    - 자바스크립트가 **싱글 스레드**여서 가능하다.
        - 싱글스레드란?
            - 한번에 하나의 작업만 수행할 수 있음을 의미한다.
    - 가장 아래는 글로벌 오브젝트의 함수가 위치한다.

## 파라미터 매핑
- 함수 호출
    - 함수가 호출되면 3개의 파라미터 값을 **실행 콘텍스트**로 넘겨준다.
    - 함수를 호출한 오브젝트, 함수 코드, 호출한 함수의 파라미터 값 을 실행 콘텍스트에 넘겨준다.
        - `obj.getTotal(11, 22, 77)` -> obj, getTotal(){....}, 11,22,77
    - **함수를 호출한 오브젝트**를 this 바인딩 컴포넌트에 설정하여 this로 참조한다.
    - **함수 코드**는 function 오브젝트의 내부 프로퍼티 [[Code]]에 설정되어 있다.
    - **호출한 함수의 파라미터 값**은 호출된 함수의 Argument 오브젝트에 설정되며 선언적 환경 레코드에 바인딩 되어 들어간다.
        - 호출된 함수 파라미터 이름은 이미 function Object에 작성되어 있다. 호출한 파라미터 값은 넘겨줘야 알 수 있다.

- 파라미터 값 매핑이란?
    - 호출한 함수에서 넘겨 준 파라미터 값을 호출된 함수의 파라미터 **작성 순서**에 맞추어 값을 매핑하는 것이다.
    - 엔진 처리의 관점
        - 실행 콘텍스트로 넘겨 준 파라미터 값과 function 오브젝트의 [[FormalParameters]] 에 작성된 이름에 값을 매핑하고 결과를 선언적 환경 레코드에 설정하여 식별자 해결을 할 수 있게 한다.
            - **FormalParameters** 란 호출된 함수의 파라미터에 작성된 이름이 들어가 있다. 이것은 function 키워드를 만나서 function object를 만들 때 설정하는 것이다.

- 파라미터 이름에 값 매핑 방법
```js
var obj = {};
obj.getTotal = function(one, two){  //파라미터 2개
    return one + two;
}
console.log(obj.getTotal(11, 22, 77));  //파라미터 3개
```
1. 실행 콘텍스트로 넘겨준 파라미터 값을 param이라고 한다면
2. getTotal 오브젝트의 [[FormalParameters]] 에서 호출된 함수의 파라미터 이름을 구한다. 이 파라미터 이름을 name이라고 한다면 name은 ["one","two"] 형태이다. [[FormalParameters]]는 function 오브젝트를 생성할 때 설정한다.
3. name 배열을 하나씩 읽는다.
4. param 에서 index 번째의 값을 구한다. 만약 index에 값이 없으면 undefined를 반환한다.
5. name의 파라미터 이름과 4번에서 구한 값을 선언적 환경 레코드에 저장한다.
    - 선언적 환경 레코드에 {one: 11, two: 22} 형태로 설정된다. 같은 이름이 있으면 값이 대체된다.<br/>
    <img src="https://github.com/nayeonkiim/TIL/blob/master/docs/JavaScript/img/6.JPG?raw=true" width="150px" height="100px" title="js" alt="one/two"></img><br/>
6. name을 전부 읽을 때까지 3~5번을 반복한다.
- 77은 매핑될 파라미터 이름이 없다. 선언적 환경 레코드에 77은 안들어간다.
- 함수 안에 작성하는 Argument Object에는 77이 들어간다.<br/>
<img src="https://github.com/nayeonkiim/TIL/blob/master/docs/JavaScript/img/5.JPG?raw=true" width="700px" height="50px" title="js" alt="param"></img><br/>

## 파라미터 값 할당 기준
```js
var obj = {};
obj.getTotal = function(one, two) {
    var one;
    console.log(one+two);
    two = 77;
    console.log("two:" + two);
}
obj.getTotal(11,22);
```
1. obj.getTotal(11, 22) 함수가 호출되면 파라미터 값을 실행 콘텍스트로 넘겨준다.
2. 파라미터 이름에 값을 매핑하여 선언적 환경 레코드에 설정한다.
    - `{one: 11, two: 22}`
3. var one;
    - 선언적 환경 레코드에서 one의 존재를 체크한다. 파라미터 이름을 설정하였으므로 존재하며 one을 기록하지 않는다.
    - one의 값이 11로 유지된다. 초기화가 되지 않는다.
4. two = 77;
    - 선언적 환경 레코드에서 two의 존재를 체크한다.(식별자 해결) 파라미터 이름을 설정하였으므로 존재하며 two를 기록하지 않는다.
    - var이 없다고 해서 무조건 global 변수인 것이 아니다.
    - one과 동일하게 two 의 값이 22로 유지된다.
5. 함수에 초기화할 코드가 없으므로 첫 번째 줄로 이동하여 함수 코드를 실행한다.
6. 선언적 환경 레코드는 {one: 11, two: 22} 상태이다.
7. var one; 은 변수 선언이므로 처리하지 않는다.
8. console.log(one+two); 에 의해 선언적 환경 레코드에서 one과 two의 값을 구한다. 11 + 22로 `33`을 출력한다.
9. two = 77; 은 현재 실행 단계(값 할당)로 two에 77을 할당하여 {two: 22}가 {two: 77}로 변경된다.
10. console.log("two:" + two); 에 의해 선언적 환경 레코드에서 two의 값을 구한다. `two: 77`을 출력한다.


### 정리 시간
```js
var obj = {};
obj.getTotal = function(one,two,two) {
    console.log(one + two);
}
obj.getTotal(11,22,55);
```
- [[FormalParameters]] 에서 호출된 함수의 파라미터 이름이 ["one","two","two"]
- 실행 콘텍스트로 넘겨준 파라미터 값 에서 
    - 0: 11, 1:22, 2:55
- 각 index 번째와 파라미터 이름을 비교해서 
    - one: 11, two: 55 가 되는 것이다.
- 11+55 로 66 이 출력된다.