---
id: es6-7
title: 7.지연성 1
---
_[함수형 프로그래밍과 JavaScript ES6+](https://www.inflearn.com/course/functional-es6/dashboard)을 보고 학습한 내용을 정리한 것입니다._

## range와 느긋한 L.range
- 연산을 미루다가 실행 코드 만났을 때 연산하는 기법
```js
//range
const range = l => {
    let i = -1;
    let res = [];
    while (++i < l) {
        res.push(i);
    }
    return res;
};

var list = range(4);
console.log(list);
console.log(reduce(add, list));


//느긋한 L.range
const L = {};
L.range = function* (l) {
    let i = -1;
    while (++i < l) {
        yield i;
    }
};

var list2 = L.range(4);
console.log(list2);
console.log(reduce(add, list2));
```
- 위의 코드 결과가
    - `[ 0, 1, 2, 3 ] 6`
        - list와 관련된 출력
    - `L.range {} 6`
        - L.list와 관련된 출력
- `console.log(list);`와 `console.log(list2);` 는 차이가 존재한다.
    - 배열 출력과 L.range {} 출력
    - L.range {} 는 이터레이터 이다. 
- **차이점**
    - range(4); 를 실행할 때 **즉시 실행**되어 완전히 평가가 된다. 
    - L.range(4) 는 이터레이터 **내부의 값을 순회할 때마다 하나씩 평가**가 된다. 
        - 즉, `list.next()` 를 해야 평가가 된다.
        - `console.log(list2.next());` 실행 시 (0 "L.range", 1 "L.range", 2 "L.range" ...) 식으로 next()를 실행함에 따라 값이 출력된다.
    - 결론 : range 함수는 함수 호출 시점에 이미 배열로 평가되어 list에 대입되었지만, L.range는 함수 호출시점에는 실제 값이 대입되지 않고 실제 호출되는 시기에 이터레이터의 내부를 순회하면서 하나씩 값이 평가 된다.
- 6 으로 같은 결과를 내긴 한다. -> 둘 모두 이터레이터 이기 때문이다.

### range와 느긋한 L.range 테스트
```js
function test(name, time, f) {
    console.time(name);
    while (time--) f();
    console.timeEnd(name);
}

test('range', 10, () => reduce(add, range(1000000)));
test('L.range', 10, () => reduce(add, L.range(1000000)));
```
- 결과는 
    - range: 628.874ms
    - L.range: 474.186ms


## take
- l 개의 수 만 iter에서 배열에 넣어 리턴한다.
    ```js
    //take
    const take = (l, iter) => {
        let res = [];
        for (const a of iter) {
            res.push(a);
            if (res.length == l) return res;
        }
        return res;
    };

    console.time('');
    console.log(take(5, range(100000)));
    console.timeEnd('');

    console.time('');
    console.log(take(5, L.range(100000)));
    console.timeEnd('');
    ```
    - 결과
        - [ 0, 1, 2, 3, 4 ]<br/>
        : 18.276ms
        - [ 0, 1, 2, 3, 4 ]<br/>
        : 0.198ms
    - 지연성을 가진 값을 이터레이터로 만들면 전혀 다른 함수가 이터러블 프로토콜만 따른다면 조합이 가능하다. 
        - console.log(take(5, L.range(100000)));
    - 위의 range는 100000 개의 값을 가진 array를 만들고 그 중 5개를 리턴한다.
    - L.range의 경우 array를 만들지 않고 딱 5개의 값만 리턴하므로 훨씬 효율적이다.
    - 위의 원리에 따라 둘 다 infinity(무한) 값을 주면
        - `console.log(take(5, range(Infinity)));` : 100000 값을 줬을 때와 동일한 시간이 걸린다.
        - `console.log(take(5, L.range(Infinity)));` : 매우 오래 걸려 에러가 발생한다.


### curry 을 take에 적용하기
```js
const take = curry((l,iter) => {
    let res = [];
    for (const a of iter) {
        res.push(a);
        if(res.length == l) return res; 
    }
    return res;
});

console.time('');
go(
    range(10000),
    take(5),
    reduce(add),
    console.log
);
console.timeEnd('');
console.time('');
go(
    L.range(10000).
    take(5).
    reduce(add),
    console.log
);
console.timeEnd('');
```
- 결과
    - 10 <br/>
    : 7.497ms
    - 10 <br/>
    : 0.14ms

## 제너레이터/이터레이터 프로토콜로 구현하는 지연 평가
- 지연 평가
    - 제때 계산법 : 가장 필요할 때까지 평가를 미루다가 필요할 때 코드를 평가하는 기법이다.
    - 제너레이터/이터레이터 프로토콜이 존재하여 지연 평가를 공식적인 일반 값으로서 구현이 가능해졌다.

### L.map 
- 지연성을 가진, 제너레이터/이터레이터 프로토콜 기반으로 구현해 본다.
- 평가를 미루는 성질, 평가 순서를 달리 조작할 수 있는 준비가 되어있는 이터레이터를 반환하는 제너레이터 함수이다.

- L.map 코드
    ```js
    L.map = function* (f, iter) {
        for (const a of iter) yield f(a);
    };
    var it = L.map(a => a + 10, [1, 2, 3]);
    // console.log(it.next()); // { value: 11, done: false }
    // console.log(it.next()); // { value: 12, done: false }
    // console.log(it.next()); // { value: 13, done: false }
    // console.log(it.next()); // { value: undefined, done: true } 

    console.log([...it]);  //[ 11,12,13 ]
    ```
    - L.map 자체에서는 새로운 array를 만들지도 않고 값 하나하나 마다 순회한다.
    - next나 [...it] 를 통해 평가할 수 있다.


### L.filter
- 지연성을 가진, 제너레이터/이터레이터 프로토콜 기반으로 구현해 본다.
    
- L.filter 코드
    ```js
    L.filter= function *(f, iter) {
        for(const a of iter) {
            if(f(a)) yield a;
        }
    };
    var it = L.filter(a => a%2, [1,2,3,4]);
    console.log(it.next());  //{ value: 1, done: false }
    console.log(it.next());  //{ value: 3, done: false }
    console.log(it.next());  //{ value: undefined, done: true }
    ```
    - f(a)의 값이 true일 때만, 반환하도록 L.map 함수에서 조건이 추가된 형태이다.
