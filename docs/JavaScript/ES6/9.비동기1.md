---
id: es6-9
title: 9.비동기1
---
_[함수형 프로그래밍과 JavaScript ES6+](https://www.inflearn.com/course/functional-es6/dashboard)을 보고 학습한 내용을 정리한 것입니다._

- 비동기 사용방법
    - callback
    - Promise 기반
        - Promise method chain 통한 함수 합성
        - async/await

## callback과 Promise
- callback 이용한 코드
    - 100ms 이후에 동작하도록 한다.
    ```js
    function add10(a, callback) {
        //받아둔 함수를 실행해서 그 함수에 결과를 전달
        setTimeout(() => callback(a + 10), 100);
    }

    add10(res, res => {
        console.log(res);
    });
    /
    ```
- Promise 이용한 코드
    - 100ms 이후에 동작하도록 한다.
        ```js
        function add20(a) {
            return new Promise(resolve => setTimeout(() => resolve(a + 20), 100));
        }

        add20(5)
            .then(console.log);
        ```
        - 프로미스의 경우, 이 함수에서 사용할 인자를 하나만 받는다.
        - add20 은 프로미스를 만들어서 리턴해준다.

- 연속적인 실행
    ```js
    //콜백을 통한 연속적인 실행
    add10(5, res => {
        add10(res, res => {
            add10(res, res => {
                console.log(res);
            });
        });
    });

    //프로미스를 통한 연속적인 실행의 경우, then만 작성해주면 된다.
    add20(5)
        .then(add20)
        .then(add20)
        .then(console.log);
    ```

## 비동기를 값으로 만드는 Promise
- Promise와 callback 함수 차이   
    - Promise는 **일급으로 비동기 상황을 다룬다**는 점이 가장 중요한 차이를 가진다. 
        - 프로미스라는 클래스를 통해서 만들어진 인스턴스를 반환한다. 반환된 프로미스 값은 대기, 성공, 실패를 다루는 일급 값으로 이루어진다.
        - 코드로만 표현되는 것이 아닌 비동기 상황에 대한 값을 만든다.
    
    - 코드로 보기
        ```js
        var a = add10(5, res => {
            add10(res, res => {
                add10(res, res => {
                    console.log(res);
                });
            });
        });

        console.log(a);  //undefined

        var b = add20(5)
            .then(add20)
            .then(add20)
            .then(console.log);

        console.log(b);  //Promise { }

        add10(5, _ => _);  //undefined
        add20(5, _ => _);  //Promise { }

        var c = add20(5, _ => _);
        console.log(c); //Promise { }
        var d = c.then(a => a - 5);
        console.log(d); //Promise { }
        ```
        - callback : add10 은 실행 후 어떤한 일도 할 수 없다. **undefined를 반환**한다.
        - Promise : add20 은 실행 후 이후에 추가적인 일도 할 수 있다. **Promise를 반환**하기 때문.
            - 비동기로 일어난 상황에 대해서 값으로 다룰 수 있고 값으로 다룰 수 있다는 것은 일급이라는 의미이다.
            - 일급이라는 것은 어떤 변수에 할당될 수 있고, 어떤 함수에 전달될 수 있고, 전달된 값으로 또 다른 일을 이어나갈 수 있다.

## 값으로서의 Promise 활용
- Promise 일급 성질로 다양한 처리가 가능하다.
- 아래의 코드가 실행되기 위한 조건으로 a, f (인자) 모두 동기적이어야 한다.
    - 바로 값을 알 수 있어야 한다. 즉, 프로미스가 아닌 값이 들어와야 한다.
    ```js
    const go1 = (a,f) => f(a);
    const add5 = a => a + 5;
    go1(10, add5);
    ```
    - 만약 프로미스 값이 들어간다면 정상적인 연산이 안된다.
    - 프로미스 값이 들어와도 정상적으로 연산하게 만들기
        ```js
        //delay100 을 Promise로
        const delay100 = a => new Promise(resolve =>
            setTimeout(() => resolve(a), 100));
        
        //promise 라도 정상적인 동작이 되도록 만든다.
        //promise라면 a.then(f)
        const go1 = (a, f) => a instanceof Promise ? a.then(f) : f(a);
        const add5 = a => a + 5;

        var r = go1(10, add5);  //15
        console.log(r);

        var r2 = go1(delay100(10), add5);
        //console.log(go1(delay100(10), add5));  //Promise { }
        r2.then(console.log);  //15
        ```
        - delay100 는 들어온 값을 100ms 뒤에 받아둔 값을 그대로 리턴해주는 함수이다. 
        - go1 함수를 Promise가 일급이라는 성질을 이용해서 비동기 상황인지를 체크한다.
            - 넘어온 인자 a 가 Promise 이면 a.then(f)를, 아니면 f(a) 를 한다.
            - 즉, 둘 다 a+5 를 수행한다. 
            - go1 함수는 다형성을 지원한다.

## 합성 관점에서의 Promise와 모나드
- 모나드
    - Promise는 비동기 상황에서 함수 합성을 안전하게 하기 위한 모나드 이다.
    - 함수 합성을 안전하게 하기 위한 도구이다.
    - **컨테이너에 값이 들어있고 그 값을 통해서 함수 합성을 안전하게 해나가는 것**이다.
    - 예시 코드
        - 인자 값을 받아 1을 더해주는 g라는 함수와 인자 값을 제곱해 반환하는 함수 f
        ```js
        const g = a => a+1;
        const f = a => a*a;
        log(f(g(1)));   //4
        log(f(g()));  //NaN
        ```
        - `log(f(g()));`
            - NaN 가 출력된다. 비정상적인 동작을 했다는 것이다.
            - 함수 합성에 사용되는 인자값이 유의미한 값이 아니여서 발생하는 문제이다.
            - 위와 같이 인자값으로 어떤 값이 올 지 모르고 빈 값이 올 수도 있다.
            - 즉, f(g(x)) 합성함수는 안전하지 않은 합성함수라고 할 수 있다. 
            - 위와 같이 **인지값으로 어떤 값이 올 지 모르는 불안한 상황에서 함수 합성을 어떻게 안전하게 할 지 고려**하며 나온 것이 `모나드` 이다.

        - 위의 코드를 모나드로 표현
            ```js
            log([1].map(g).map(f));  // [4]
            ```
            - 모나드는 박스를 가지고 있고 그 내부의 실제 효과나 연산에 필요한 재료들을 가지고 있고 이를 통해 함수 합성을 한다.
                - [1] : 박스 안의 재료는 1
            - 반환값이 Array이고 최종 유효값으로 볼 수는 없다. 그렇기 때문에 Array 안에 있는 최종 값을 꺼내야 한다.<br/><br/>
                ```js
                [1].map(g).map(f).forEach(r => console.log(r));  // 4
                ```
                - `log(f(g(1)));` 와 동일

        - 모나드를 통한 함수 합성의 이점
            ```js
            [1].map(g).map(f).forEach(r=>log(r));  // 4
            [].map(g).map(f).forEach(r=>log(r));  // 결과 없음
            ```
            - 박스 안에 효과가 있는지 없는지에 따라서 함수 합성을 안전하게 하고 있다는 의미이다.
            - log(f(g())); 의 경우 빈 값이 들어와도 빈 값을 나타내는 효과까지 가는데, 모나드 방식을 사용하면 안전하게 효과를 아예 일으키지 않는 식으로 작동한다. => 안전하게 함수 합성 
                - 위의 [ ] 은 유효하지 않은 값이 들어와 결과가 없다.
- Promise
    - 모나드와 동일한 방식으로 구현된다.
    ```js
    //Array 함수 합성
    Array.of(1).map(g).map(f).forEach(r => console.log(r));   // 4
 
    Promise.resolve(1).then(g).then(f).then(r => console.log(r));  //4
    ```
    - Promise 는 then() 을 통해서 함수 합성을 한다.
    - Promise 는 안에 값이 있거나 없거나에 대한 안전한 합성을 하기 위한 것은 아니고 **비동기 상황을 안전하게 합성하기 위한 도구**이다.
    - 비동기 상황이란, 얼마만큼 지연이 필요한 상황에서도 함수를 적절한 시점에 평가해서 합성 시키기 위한 도구이다.
    

## Kleisli Composition 관점에서의 Promise
