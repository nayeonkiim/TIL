---
id: design2
title: 2.옵저버 패턴
---
_학교 수업 소프트웨어 설계 패턴을 듣고 정리한 내용입니다._

## 학습 목표
- 옵저버 패턴이 필요한 상황을 이해한다. (문제 상황)
- 옵저버 패턴의 작동 매커니즘을 이해한다. (해결 방안)
- 옵저버 패턴을 직접 구현해 본다.
- 자바 내장 옵저버 패턴을 사용해 보고, 이의 장단점을 분석해본다.
- 옵저버 패턴의 적용 예를 이해한다.

## 문제 상황
- 기상 모니터링 애플리케이션
    - 구성요소
        1. **기상 스테이션(Weather Station)** : 실제 기상 정보를 수집하는 장비
            - 온도, 습도, 압력을 측정하는 센서를 보유한다.
        2. **WeatherData 객체** : 기상 스테이션으로부터 수집된 데이터
            - 측정된 온도, 습도, 압력값은 받는 getXXX 메서드가 존재
            - 새로운 측정 데이터가 나올 때마다 호출되는 메소드가 존재 (measurementsChanged())
        3. **디스플레이 장비 종류**
            - 현재 조건(온도, 습도, 압력)
            - 기상 통계
            - 기상 예보<br/>
            <img src="https://github.com/nayeonkiim/TIL/blob/master/docs/Design Patterns/img/7.JPG?raw=true" width="500px" height="250px" title="Weather" alt="Weather"></img><br/>

### 간단한 구현 방안

```java
public class WeatherData {
    //인스턴스 변수 선언

    public void measurementsChanged() {
        float temp = getTemperature();
        float humidity = getHumidity();
        float pressure = getPressure();

        //변화가능한 부분 - 디스플래이 갱신
        currentConditionDisplay.update(temp, humidity, pressure);
        statisticsDisplay.update(temp,humidity,pressure);
        forecastDisplay.update(temp,humidity,pressure);
    }
}
```
- 변화 가능한 부분은 update() 를 통해 디스플래이 갱신하는 부분들이다.
- 변화 가능한 부분은 새로운 종류의 디스플레이가 추가 혹은 삭제 될때 WeatherData 클래스에서 직접 변경된 값을 적용한다면 update() 부분이 항상 영향을 받게 된다.
- 변화 가능한 부분을 어떻게 캡슐화하여 이의 변화가 WeatherData 클래스에 영향을 주지 않도록 설계할 것인가?

### 디자인 원칙 : 서로 상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.
- 상호작용하는 두 객체가 서로의 구체적인 실체 및 구현에 대해서는 모르고, 단지 **서로의 추상화된 인터페이스만**을 알고 있음을 의미한다.

## 옵저버 패턴
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들(옵저버)한테 연락이 가고, 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의.
- facebook에서 소식을 등록하면 자동으로 친구들에게 모두 소식이 알려지는 것과 동일하다.
<br/><img src="https://github.com/nayeonkiim/TIL/blob/master/docs/Design Patterns/img/8.JPG?raw=true" width="500px" height="250px" title="Weather" alt="Weather"></img><br/>

### 옵저버 동작 원리
1. 주제 하나에 옵저버가 등록(register) 요청에 의해 등록이 된다.
2. 주제의 상태 변경 시, 옵저버들 자동 갱신(notify)이 일어난다.
3. 옵저버가 주제에 대해 탈퇴(remove)를 요청하면 둘 사이의 연결이 없어진다.<br/><br/>

### 기상 모니터링에 옵저버 패턴 적용
- [전체코드](https://github.com/kwanulee/DesignPattern/tree/master/observer/WeatherStationObserverPattern/src/hansung/designpatterns/observer)
1. 인터페이스
    - Subject 인터페이스 : 주제 하나에 옵저버를 등록, 제거, 업데이트틀 하는 메서드가 담겨있다.
    - Observer 인터페이스 : Observer 업데이트를 정의하기 위한 메서드가 담겨있다.
    - DisplayElement 인터페이스 : 출력을 정의하기 위한 메서드가 담겨있다. 
2. 클래스
    - CurrentConditionsDisplay : Observer와 DisplayElement 인터페이스를 구현하며 온도와 습도 정보를 나타낸다.
    - StatisticsDisplay : Observer와 DisplayElement 인터페이스를 구현하며 변화된 온도의 평균/최대/최소값 정보를 나타낸다.
    - ForecastDisplay : Observer와 DisplayElement 인터페이스를 구현하며 변화 전 온도와 변화 후 온도를 비교한 정보(추운지 더운지)를 나타낸다.
    <br/><img src="https://github.com/nayeonkiim/TIL/blob/master/docs/Design Patterns/img/9.JPG?raw=true" width="500px" height="280px" title="Weather" alt="Weather"></img><br/>
3. 실행 결과
    ```java
    weatherData.setMeasurements(80, 65, 30.4f);
	weatherData.setMeasurements(82, 70, 29.2f);
    ```
    ```
    Current conditions: 80.0F degrees and 65.0% humidity
    Avg/Max/Min temperature = 80.0/80.0/80.0
    Forecast: Improving weather on the way!
    Current conditions: 82.0F degrees and 70.0% humidity
    Avg/Max/Min temperature = 81.0/82.0/80.0
    Forecast: Watch out for cooler, rainy weather
    ```

### 정리
- `weatherData.setMeasurements(80, 65, 30.4f);` <br/>
    : setMeasurements 를 통해 온도,습도,압력에 대한 변화된 값만 알려주면 weatherData(Subject) 에 의존하고 있는 옵저버들에 연락이 가고 자동으로 갱신이 된다.

- Subject 인터페이스를 구현한 WeatherData 의 메서드 구성이 아래와 같기 때문에 가능하다.
    - setMeasurements 메서드에서 변화된 값으로 필드를 각각 변화시키고 measurementsChanged 메서드를 호출한다.
    - 호출된 measurementsChanged 메서드에서 다시 notifyObservers 메서드를 호출한다.
    - 호출된 notifyObservers 메서드에서 모든 옵저버에 변경된 값으로 업데이트 하는 update 메서드를 호출한다.
    - update() 는 Observer 인터페이스를 구현한 각 옵저버에서 재정의 되어 있다.

    ```java
    public void setMeasurements(float temperature, float humidity, float pressure) {
		this.temperature = temperature;
		this.humidity = humidity;
		this.pressure = pressure;
		measurementsChanged();
	}

    //측정값이 변경되면 모든 옵저버에 update 하는 메소드 호출
	public void measurementsChanged() {
		notifyObservers();
	}

    //모든 옵저버를 update
	public void notifyObservers() {
		for (Observer observer : observers) {
			observer.update(temperature, humidity, pressure);
		}
	}
    ```

## 자바 내장 옵저버 패턴 사용하기
### java.util.Observer 인터페이스
- 앞의 Obserer 인터페이스와 유사하다.
- update(Observable o, Object arg) 메서드가 있다.
### java.util.Observable 클래스
- 앞의 Subject 인터페이스와 관련된 구현을 포함한 클래스
- 옵저버 등록, 탈퇴, 알림 기능의 메서드가 존재한다.
- addObserver(Observer), deleteObserver(Observer), notifyObservers(), setChanged()
- setChanged()는 Observable 객체의 상태가 변경되었다는 것을 알리기 위해 호출된다.

### 내장 옵저버 패턴 사용하기

<br/><img src="https://github.com/nayeonkiim/TIL/blob/master/docs/Design Patterns/img/10.JPG?raw=true" width="500px" height="280px" title="Weather" alt="Weather"></img><br/>

- Subject 를 구현했던 WeatherData 클래스는 Observable 클래스를 상속받는다.
- setMeasurements 메서드를 통해 변경된 값이 들어오면 measurementsChanged 메서드를 호출한다.
- 호출된 measurementsChanged 메서드는 setChanged() 로 상태가 변경 되었음을 알려주고 notifyObservers() 로 등록된 옵저버에게 변경된 상태값이 반영이 된다.
    ```java
    public class WeatherData extends Observable {
        ...
        public void measurementsChanged() {
            setChanged();
            notifyObservers();
        }
        
        public void setMeasurements(float temperature, float humidity, float pressure) {
            this.temperature = temperature;
            this.humidity = humidity;
            this.pressure = pressure;
            measurementsChanged();
        }
        ...
    }
    ```
- Observable 클래스 살펴보기
    - setChanged() 메소드를 호출해 주어 changed를 true로 설정해 줘야  notifyObservers() 가 호출되었을 때, 등록된 옵저버들에게 연락(update)을 취하게 된다.
    - notifyObservers 메서드 안에서 update 메서드를 호출한다.

    ```java
    class Observable {
        …
        setChanged() {
            changed = true
        }
        notifyObservers(Object arg) {
            if (changed) {
                for all observers {
                    update(this, arg)
                }
            changed = false
            }
        }
        notifyObservers() {
            notifyObservers(null)
        }
        …
    }
    ```
## Pull vs Push
- Pull 방식
    - update(Observable obs, Object arg)
        - Observable 객체를 통해 필요한 값만 getXXX 을 통해 가져올 수 있다. 
        - getTemperature(), getHumidity()
    - notifyObservers() 로 변경이 통지되면 update의 파라미터인 Observable 객체를 통해 데이터를 수집한다. 

    ```java
    public class CurrentConditionsDisplay implements Observer, DisplayElement {
        public void update(Observable obs, Object arg) {
            if (obs instanceof WeatherData) {
                WeatherData weatherData = (WeatherData)obs;
                this.temperature = weatherData.getTemperature();
                this.humidity = weatherData.getHumidity();
                display();
            }
        }
    }
    ```
- Push 방식
    - 변경 통지와 데이터 전송이 함께 일어난다.
    - update(float temperature, float humidity, float pressure) 의 파라미터를 통해 모든 데이터가 전달된다. 즉 데이터 전송이 일어난다.
    
    ```java
    public class CurrentConditionsDisplay implements Observer, DisplayElement {
        public void update(float temperature, float humidity, float pressure) {
            this.temperature = temperature;
            this.humidity = humidity;
            display();
        }
    }
    ```

## 참고
- [교수님 github](https://github.com/kwanulee/DesignPattern)
- [교재 Head First Design Patterns](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=582754)
- 강의자료