---
id: JPA11
title: 객체지향 쿼리 언어1 - 기본 문법
---
_[자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic)을 보고 학습한 내용을 정리한 것입니다._

## JPA의 다양한 쿼리 방법 지원
- JPQL
- JPA Criteria
- QueryDSL
    - 자바 코드로 짠 코드를 JPQL를 build 해주는 generator 모음
- 네이티브 SQL
    - 데이터베이스 종속적인 쿼리를 실행해야 할 때
- JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 햠께 사용

### JPQL
- JPA는 SQL을 추상화한 JPQL이라는 객체지향 쿼리 언어를 제공한다.
- JPQL은 엔티티 객체를 대상으로 쿼리
- SQL은 데이터베이스 테이블을 대상으로 쿼리

```java
try {
    //Member는 엔티티를 가르킴, query,타입
    List<Member> result = em.createQuery(
                "select m From Member m where m.username like '%kim%'",
                Member.class
    ).getResultList();

    for(Member m : result)
        System.out.println("member = " + result);

    tx.commit();
}
```
```sql
Hibernate: 
    /* select
        m 
    From
        Member m 
    where
        m.username like '%kim%' */ select
            member0_.MEMBER_ID as member_i1_6_,
            member0_.city as city2_6_,
            member0_.street as street3_6_,
            member0_.zipcode as zipcode4_6_,
            member0_.endDate as enddate5_6_,
            member0_.startDate as startdat6_6_,
            member0_.USERNAME as username7_6_ 
        from
            Member member0_ 
        where
            member0_.USERNAME like '%kim%'
```
- JPQL 쿼리인 엔티티 대상 쿼리를 넣어주면 엔티티 매핑 정보를 읽어 적절한 sql 쿼리을 만들어 낸다.
- `"select m From Member m where m.username like '%kim%'"`
    - sql 문의 경우 m이 아닌 * 나 column명을 적어주는데 JPQL은 엔티티 대상이므로 m을 넣어준다. m은 Member를 가르킨다.
- JPQL 쿼리은 단순 문자열이기 때문에 동적 쿼리를 만들기 어렵다.


### Criteria
- 동적 쿼리를 깔끔하게 만들 수 있다.
- java 코드로 JPQL을 작성하기 때문에 에러도 잡아준다.
- sql 스럽지 않고 유지보수가 어려워서 실무에서 사용하지 않는다.
- Criteria 대신에 QueryDSL 사용을 권장한다.
```java
try {
    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery<Member> query = cb.createQuery(Member.class);

    Root<Member> m = query.from(Member.class);

    CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
    List<Member> resultList = em.createQuery(cq)
                    .getResultList();

    tx.commit();
}
```
```sql
Hibernate: 
    /* select
        generatedAlias0 
    from
        Member as generatedAlias0 
    where
        generatedAlias0.username=:param0 */ select
            member0_.MEMBER_ID as member_i1_6_,
            member0_.city as city2_6_,
            member0_.street as street3_6_,
            member0_.zipcode as zipcode4_6_,
            member0_.endDate as enddate5_6_,
            member0_.startDate as startdat6_6_,
            member0_.USERNAME as username7_6_ 
        from
            Member member0_ 
        where
            member0_.USERNAME=?
```

### QueryDSL
- 문자가 아닌 자바코드로 JPQL을 작성할 수 있다.
- JPQL 빌더 역할
- 컴파일 시점에 문법 오류를 찾을 수 있다.
- 동적 쿼리 작성이 편리하다.
```java
//JPQL
//select m from Member m where m.age > 18
JPAFactoryQuery query = new JPAQueryFactory(em);
QMember m = QMember.member;

List<Member> list = 
        query.selectFrom(m)
             .where(m.age.gt(18))
             .orderBy(m.name.desc())
             .fetch();
```
- JPQL을 잘 알아야 한다.
- [QueryDSL Reference](http://www.querydsl.com/static/querydsl/4.4.0/reference/html_single/#jpa_integration)

### 네이티브 
- JPA가 제공하는 SQL을 직접 사용하는 기능이다.
- JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능이다.
- ex) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트
```java
try {
    em.createNativeQuery("select MEMBER_ID, city, street, zipcode, USERNAME from MEMBER")
        .getResultList();
    tx.commit();
}
```
```sql
Hibernate: 
    /* dynamic native SQL query */ select
        MEMBER_ID.,
        city,
        street,
        zipcode,
        USERNAME 
    from
        MEMBER
```

### JDBC 직접 사용, SpringJdbcTemplate 등
- JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스 등을 함께 사용 가능하다. 네이티브 보다 위 방법을 좀 더 선호한다.
- 단 영속성 컨텍스트를 적절한 시점에 **강제로 플러시**가 필요하다.
    - flush는 commit, query 시 에 자동으로 된다.
    - 따라서 아래의 코드는 em.persist에 의해 아직 db에 들어간 상태는 아니지만 em.createNativeQuery 에 의해 flush 된 후 select 문을 실행하게 된다.
    - jpa 관련 기술을 사용하면 문제가 발생하지 않는다.
    ```java
    Member member = new Member();
    member.setUsername("member1");
    em.persist(member);
            
    em.createNativeQuery("select MEMBER_ID, city, street, zipcode, USERNAME from MEMBER",
                Member.class).getResultList();
    tx.commit();
    ```
    - 하지만 만약 db connection을 얻어오는 경우는 JPA 와 연관이 없어서 flush가 되지 않는다.
    - 아직 db에 들어간 데이터가 아니기 때문에 데이터 select 이 되지 않는다.
    ```java
    Member member = new Member();
    member.setUsername("member1");
    em.persist(member);

    dbConnection.executeQuery("select * from member");
    ```
    - => 강제로 flush 를 해야 한다.

## JPQL
- **엔티티 객체**를 대상으로 쿼리 한다.
- JPQL은 SQL을 추상화해서 **특정 데이터베이스 SQL에 의존하지 않는다.**
- JPQL은 결국 SQL로 변환된다.<br/><br/>

- JPQL 문법
    - select m from Member m where m.age > 18
        - Member가 엔티티. 엔티티의 이름을 사용한다.
    - 별칭은 필수이다. Member `m`
- 집합과 정렬
    - GROUP BY, HAVING
    - ORDER BY
    - 모두 동일하게 실행 가능 하다.

- TypeQuery, Query
    - TypeQuery : 반환 타입이 명확할 때 사용한다.<br/><br/>
        ```java
        TypedQuery<Member> query = em.createQuery("select m from Member m", Member.class);
        ```
    - Query : 반환 타입이 명확하지 않을 때 사용한다.
        - m.username 은 String 타입, m.age는 int 타입 => 서로 다른 타입인 경우<br/><br/>
        ```java
        Query query = em.createQuery("select m.username, m.age from Member m");
        ```

- 결과 조회 API
    - 결과가 collection인 경우 -> **query.getResultList()**
        - 결과가 하나 이상인 경우 리스트 반환.
        - **결과가 없는 경우 빈 리스트 반환.**
        ```java
        TypedQuery<Member> query = em.createQuery("select m from Member m", Member.class);
        List<Member> resultList = query.getResultList();

        for(Member member1 : resultList) {
            System.out.println("member1 = " + member1);
        }
        ```
    - 결과가 하나인 경우 : **query.getSingleResult()**
        - 결과가 **정확히 하나**인 경우 단일 객체 반환
        - 결과가 없으면 : javax.persistence.NoResultException -> try-catch 필요
        - 둘 이상이면 : javax.persistence.NonUniqueResultException
        ```java
        TypedQuery<Member> query = em.createQuery("select m from Member m where m.id = 10L",Member.class);
        Member result = query.getSingleResult();

        System.out.println("result = " + result);
        ```    
        - spring data jpa 에서는 하나만 가져오는 함수 제공한다. 결과없으면 null이나 optional을 반환한다.

- 파라미터 바인딩 - 이름 기준, 위치 기준
    - 이름 기준
    - where m.username = **:username**
    ```java
    TypedQuery<Member> query = em.createQuery("select m from Member m where m.username = :username", Member.class);
    query.setParameter("username", "member1");
    Member singleResult = query.getSingleResult();
    System.out.println("singleResult = " + singleResult);
    ```
    - 위의 코드를 체이닝으로 구현
    ```java
    Member result = em.createQuery("select m from Member m where m.username = :username", Member.class)
            .setParameter("username", "member1")
            .getSingleResult();

    System.out.println("result = " + result.getUsername());
    ```

    ```sql
    Hibernate: 
    /* select
        m 
    from
        Member m 
    where
        m.username = :username */ select
            member0_.id as id1_0_,
            member0_.age as age2_0_,
            member0_.TEAM_ID as team_id4_0_,
            member0_.username as username3_0_ 
        from
            Member member0_ 
        where
            member0_.username=?
    singleResult = jpql.Member@538cd0f2
    ```

    - 위치 기준 - 사용 권장 x

## 프로젝션
- select 절에 조회할 대상을 지정하는 것이다.
- 프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자 등 기본 데이터 타입)
    - 관계형 데이터베이스의 경우 스칼라 타입만 넣을 수 있다.
    - select m from Member m (엔티티)
    - select m.team from Member m (엔티티 프로젝션)
    - select m.address from Member m (임베디드 타입 프로젝션)
    - select m.username, m.age from Member m (스칼라 타입 프로젝션)
    - DISTINCT 로 중복 제거할 수 있다.
